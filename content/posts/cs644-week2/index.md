+++
date = '2025-09-09T19:18:12-04:00'
draft = true
title = 'Cs644 Week2'
+++

- Freeing memory twice becomes a memory vulnerability (potentially).

In class assignments:

1. Let's take a look at the APIs that your programming languages of choice expose for making system calls on Linux.

2. Use `man 2 read` to view the manual page for the `read` syscall.

3. Write a program that reads a file in fixed-size chunks and prints the number of bytes in the file. (Next week we'll learn a more efficient way to do this.)

	- Think about chunk, chunk, and then count until null terminator at the end.

    ```c
      // Read file
    read_amt = read(fd, buffer, chunk_size);
    while (read_amt > 0) {
        read_count += read_amt;
        read_amt = read(fd, buffer, chunk_size);
    }
    ```

    `read` will return 0 when done.

4. Write a program that appends a line of text to a file, creating it if it does not already exist. Do it once with `O_APPEND` and once with `lseek`.

5. Let's use `strace` to see what system calls some common Linux utilities use.

1. (★) What's the difference between a syscall and a function call?

A syscall is issued at the system level, whereas a function call is essentially a language-specific wrapper for that call.

2. (★) How do you distinguish between an I/O error and reaching the end of the file with `read`?

`read` will return -1 if an error has happened, and populate `errno` with the appropriate error number. Instead, it will return `0` if the end of the file has been reached.

3. (★) What flags do I pass to `open` to open a file for writing at the end?
   
`O_RDWR`, or `O_APPEND`

4. (★★) `EACCES`, `EEXIST`, and `ENOENT` are three common errors that `open` can return. Read the description of these errors in `man 2 open`, and write a program that demonstrates each of them.

`EACCESS` - Mainly to do with permissions errors, but can also reflect non-existent files.
`EEXIST` - If create but no overwrite flags are set, and a file exists.
`ENOENT` - Something that we expected to exist doesnt.

5. (★★) Modify your program from in-class exercise 3 to count the number of whitespace characters in the file. Try it out on `/usr/share/cs644/bigfile.txt`. Experiment with different chunk sizes. How does it affect the performance of your program? (Tip: Run `time ./myprogram` to measure the running time of your program.)
   
It turns out that larger chunk sizes result in a faster program! Using `clock` is a fairly useful way of going about it, as it seems more precise and allows us to specify only what we want to measure.

6.  (★★) Why does `read` return the number of bytes read? Why doesn't it just set `buf` to a null-terminated string, like other C functions?
   
We might overflow our buffer. We also might be reading things that aren't necessarily null-terminated, like streams of numbers, or even characters, generated by other programs.

7.  (★★) If you call `write`, use `lseek` to rewind, and call `read` again, are you guaranteed to see the data you just wrote? Find the place in the man pages that describes Linux's behavior. Write a program to demonstrate it.

`write` buffers data, and can return before said buffers are flushed. `lseek` in turn does *not* flush buffers, meaning that there is a chance that `read` will in turn return stale data. The only real cure for this is to use `fsync()` to ensure data is flushed.

8.  (★★★) Modify your program from exercise 3 to read a file line-by-line.

```c
  int buffer_cursor = 0;
  char char_buffer[1];
  char str_buffer[1024];

  while (lseek(fd, (off_t)0, SEEK_CUR) > -1) {
    int read_status = read(fd, char_buffer, 1);
    if (read_status == 0) {
      return 0;
    }

    str_buffer[buffer_cursor] = char_buffer[0];
    str_buffer[buffer_cursor + 1] = '\0';

    if (char_buffer[0] == '\n') {
      printf("%s\n\n", str_buffer);
      memset(str_buffer, 0, sizeof str_buffer);
      buffer_cursor = 0;
    } else {
      buffer_cursor += 1;
    }
  }
```

Is there an easier way to do this than calling `read` for every character? 

9.  (★★★) What happens when one program is reading from a file while another program is writing? Formulate a hypothesis, then write a pair of programs to test it.